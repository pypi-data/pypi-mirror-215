# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api.ipynb.

# %% auto 0
__all__ = ['MaticaAPIClient']

# %% ../nbs/api.ipynb 3
import paramiko
import scp as scp2
import base64
import requests
import time

# %% ../nbs/api.ipynb 4
class MaticaAPIClient(object):
    



    time_span = 2

    @staticmethod
    def main(hostname, username, api_key, location_uuid, ssh_username, ssh_password, task_id, uploaded_file_path, transfer_type, transfer_accession, storage_username, storage_password, file_dir_path='/home/files'):
        client = MaticaAPIClient(hostname, username, api_key, location_uuid, ssh_username, ssh_password, task_id, storage_username, storage_password, file_dir_path=file_dir_path)
        client.upload(uploaded_file_path)
        directory = client.transfer(transfer_type, transfer_accession)

        transfer_UUID = client.approve_transfer(transfer_type, directory)

        sip_UUID = client.check_transfer_status(transfer_UUID)

        # ingest
        ingest_UUID = client.ingest(sip_UUID)

        url = client.get_aip_url(ingest_UUID)

        return url

    # stage = 0

    def status(self, params):
        # if self.stage == 0:
        if not any(params):

            self.upload(self.uploaded_file_path)
            self.transfer(self.transfer_type, self.transfer_accession)

            self.stage = 1

            return {
                "data": {
                    "type": self.transfer_type,
                    "directory": self.directory
                },
                "status": "transfer started"
            }
        # elif self.stage == 1:
        elif "directory" in params:
            
            data = {
                "type": params["type"], # self.transfer_type,
                "directory": params["directory"] # self.directory
            }

            response3 = requests.post(f'{self.endpoint}/transfer/approve/', headers=self.headers, data=data)

            if "uuid" in response3.json():
                self.stage = 2

                self.transfer_UUID = response3.json()["uuid"]

                return {
                    "data": {
                        "transfer_UUID": self.transfer_UUID
                    },
                    "status": "transfer approved"
                }
            
            
            return {
                "status": "transfer approving"
            }
        # elif self.stage == 2:
        elif "transfer_UUID" in params:

            transfer_UUID = params["transfer_UUID"] # self.transfer_UUID

            response5 = requests.get(f'{self.endpoint}/transfer/status/{transfer_UUID}', headers=self.headers)

            r = response5.json()

            if "status" in r and r["status"] != "PROCESSING":
                # break
                self.stage = 3

                self.sip_UUID = response5.json()["sip_uuid"]

                # time.sleep(self.time_span)

                # return response5.json()["sip_uuid"]

                return {
                    "data": {
                        "sip_UUID": self.sip_UUID
                    },
                    "status": "transfer done"
                }

            return {
                "status": "transfer processing"
            }
        # elif self.stage == 3:
        elif "sip_UUID" in params:

            sip_UUID = params["sip_UUID"] # self.sip_UUID

            if "download" in params:
                return {
                    "status": "completed",
                    "data": self.get_aip_url(sip_UUID)
                }

            response4 = requests.get(f'{self.endpoint}/ingest/status/{sip_UUID}', headers=self.headers)

            r = response4.json()

            if "status" in r and r["status"] != "PROCESSING":
                # break
                self.stage = 4
                return {
                    "data": {
                        "ingest_UUID": response4.json()["uuid"],
                        "download": 1
                    },
                    "status": "ingest done",
                }

            return {
                "status": "ingest processing"
            }
        
        # 
        else:
            return {
                "status": "completed",
                "data": self.get_aip_url(self.sip_UUID)
            }


    def __init__ (self, hostname, username, api_key, location_uuid, ssh_username, ssh_password, task_id, uploaded_file_path, transfer_type, transfer_accession, storage_username, storage_password, file_dir_path='/home/files'):
        self.hostname = hostname
        self.username = username
        self.api_key = api_key
        self.location_uuid = location_uuid

        self.ssh_username = ssh_username
        self.ssh_password = ssh_password

        self.task_id = task_id

        self.file_dir_path = file_dir_path # f'/home/files'

        self.task_dir_path = f'{self.file_dir_path}/{self.task_id}/'

        self.headers = {'Authorization': f'ApiKey {username}:{api_key}'}

        self.endpoint = f"http://{hostname}:81/api"

        self.storage_username = storage_username
        self.storage_password = storage_password

        self.uploaded_file_path = uploaded_file_path
        self.transfer_type = transfer_type
        self.transfer_accession = transfer_accession

    def __init2__(self, hostname, username, api_key, location_uuid, ssh_username, ssh_password, task_id, storage_username, storage_password, file_dir_path='/home/files'):
        self.hostname = hostname
        self.username = username
        self.api_key = api_key
        self.location_uuid = location_uuid

        self.ssh_username = ssh_username
        self.ssh_password = ssh_password

        self.task_id = task_id

        self.file_dir_path = file_dir_path # f'/home/files'

        self.task_dir_path = f'{self.file_dir_path}/{self.task_id}/'

        self.headers = {'Authorization': f'ApiKey {username}:{api_key}'}

        self.endpoint = f"http://{hostname}:81/api"

        self.storage_username = storage_username
        self.storage_password = storage_password

        pass

    def upload(self, uploaded_file_path):
        task_dir_path = self.task_dir_path


        with paramiko.SSHClient() as ssh:
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(self.hostname, port=22, username=self.ssh_username, password=self.ssh_password)

            ssh.exec_command(f"mkdir -p {task_dir_path}")

            with scp2.SCPClient(ssh.get_transport()) as scp:
                scp.put(f'{uploaded_file_path}', task_dir_path)

    def transfer(self, transfer_type, transfer_accession):
        task_dir_path = self.task_dir_path
        paths = [task_dir_path]
        row_ids = [""]

        # base64へのエンコード
        paths_encoded = []
        for path in paths:
            path_encoded = base64.b64encode(f"{self.location_uuid}:{path}".encode()).decode()
            paths_encoded.append(path_encoded)

        data = {
            "name": self.task_id,
            "type": transfer_type,
            "accession": transfer_accession,
            "paths[]": paths_encoded,
            "row_ids[]": row_ids
        }

        response = requests.post(f'{self.endpoint}/transfer/start_transfer/', headers=self.headers, data=data)

        # pass

        directory = response.json()["path"].split("/")[-2]

        self.directory = directory

        return directory
    
    def approve_transfer(self, transfer_type, directory):
        while 1:

            data = {
                "type": transfer_type,
                "directory": directory
            }

            response3 = requests.post(f'{self.endpoint}/transfer/approve/', headers=self.headers, data=data)

            if "uuid" in response3.json():
                break

            time.sleep(self.time_span)

        transfer_UUID = response3.json()["uuid"]

        self.transfer_UUID = transfer_UUID

        return transfer_UUID
    
    def check_transfer_status(self, transfer_UUID):
        while 1:

            response5 = requests.get(f'{self.endpoint}/transfer/status/{transfer_UUID}', headers=self.headers)

            r = response5.json()

            if "status" in r and r["status"] != "PROCESSING":
                break

            time.sleep(self.time_span)

        sip_uuid = response5.json()["sip_uuid"]

        self.sip_uuid = sip_uuid

        return sip_uuid
    
    def ingest(self, sip_UUID):
        while 1:

            response4 = requests.get(f'{self.endpoint}/ingest/status/{sip_UUID}', headers=self.headers)

            r = response4.json()

            if "status" in r and r["status"] != "PROCESSING":
                break

            time.sleep(self.time_span)

        return response4.json()["uuid"]
    
    def get_aip_url(self, ingest_UUID):
        endpoint2 = f"http://{self.hostname}:8001/api"
        url2 = f"{endpoint2}/v2/file/{ingest_UUID}/download/"

        # response6 = requests.get(url2, auth=HTTPBasicAuth(self.storage_username, self.storage_password))

        '''
        output_path = "/Users/nakamura/git/kim/matica_tools/demo/test.7z"
        with open(output_path ,mode='wb') as f: # wb でバイト型を書き込める
            f.write(response6.content)
        '''

        # return response6.content
        return url2
