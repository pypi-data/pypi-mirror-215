# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['CalibrationModel']

# %% ../nbs/00_core.ipynb 3
import pandas as pd
import scipy as sp
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from dataclasses import dataclass
import typing

# %% ../nbs/00_core.ipynb 6
class CalibrationModel:

    def __init__(self, x, y, test_replicates):
      
        self.x = x
        self.y = y
        self.slope = None
        self.intercept = None
        self.r_squared = None
        self.std_err = None
        self.test_replicates = test_replicates
        self.cal_line_points = self.x.shape[0]
        self.df_resid = self.cal_line_points - 2
        self.sr = None
        self.mean_replicate_observations = None
        self.average_response_cal_line = None

    def fit_ols(self):

        self.slope, self.intercept, self.r_squared, self.std_err, _ = sp.stats.linregress(self.x, self.y)
    
    def calculate_fitted_values(self):
        
        self.fitted_values = self.slope * self.x + self.intercept

    
    def calculate_sse(self):
        self.calculate_fitted_values()
        return np.sum((self.fitted_values - self.y) **2)
    
    def calculate_syx(self):
        return np.sqrt((self.calculate_sse())/(len(self.x)-2))

    def get_t_value(self,alpha):
        return sp.stats.t.ppf(1 - alpha/2, self.df_resid)

    def calculate_uncertainty(self):
        return self.calculate_sxhat() * self.get_t_value(0.05)
    

    
    def calculate_hibbert_uncertainty(self, sr, test_repeats, y0, average_response_cal_line, sumsquares):
        return (1/self.slope) * np.sqrt(((sr**2)/test_repeats) + ((self.calculate_syx()**2)/self.cal_line_points) + 
                                                                   (((self.calculate_syx()**2)*((y0-average_response_cal_line)**2))/((self.slope**2)*(sumsquares))))

    
    def calculate_sxhat(self):
        return (self.calculate_syx() / self.slope) * np.sqrt( 1/ self.test_replicates + 1 / self.cal_line_points) 
    
    def fit_model(self):
        self.fit_ols()
        self.calculate_uncertainty()
        self.tabulate_results()

    def inverse_prediction(self, unknown):

        if len(unknown) > 1:
            y0 = np.mean(unknown)
            sr = np.std(unknown)
            test_repeats = len(unknown)
            average_response_cal_line = np.mean(self.y)
            sumsquares = np.sum((self.x - self.x.mean())**2)

            pred =  (y0 - self.intercept)/self.slope
        
            return f"{pred} ± {self.calculate_hibbert_uncertainty(sr=sr, y0=y0, test_repeats=test_repeats, average_response_cal_line=average_response_cal_line, sumsquares=sumsquares) * self.get_t_value(0.05)}"
        else:
            y = unknown[0]
            pred = (y - self.intercept)/self.slope
            return f"{pred} ± {self.calculate_uncertainty()}"

    def tabulate_results(self):
        print(f"Calibration curve")
        print(f"R2 = {self.r_squared}")
        print(f"Slope = {self.slope}")
        print(f"Intercept = {self.intercept}")
        print(f"Uncertainity = {self.calculate_uncertainty()}")
        # print(f"Prediction = {self.inverse_prediction()}")
