{ "version": 3, "file": "OUTPUT_ROOT/temper-std/py/temper_std/testing__preface.py", "sources": [ "std/testing.temper.md" ], "sourcesContent": [ "For now, we use mutable global state to track test results in the interpreter.\n\n    private var passing: Boolean = true;\n    private var messages = new ListBuilder\u003cString\u003e();\n\nTODO We looked at the idea of test blocks, but do we still support this?\n\n    @connected(\u0022::test\u0022)\n    export let test(name: String, body: fn (): Void): Void {\n      passing = true;\n      messages = new ListBuilder\u003cString\u003e();\n      // TODO exception handling?\n      body();\n      if (passing) {\n        console.log(\u0022\u0024{name}: Passed\u0022);\n      } else {\n        console.log(\u0022\u0024{name}: Failed \u0024{messages.join(\u0022\\n\u0022) { (it);; it }}\u0022);\n      }\n    }\n\nCurrently for tests, you should extend `TestFixtureBase` and then decorate test\nmethods inside your test class with `@test`.\n\n    export interface TestFixtureBase {\n\n    }\n\nWe currently support a single `assert` method, for which we still need to refine\nhow we provide failure messages.\n\n    @connected(\u0022::assert\u0022)\n    export let assert(success: Boolean, message: fn (): String): Void {\n      if (!success) {\n        passing = false;\n        messages.add(message());\n      }\n    }\n" ], "names": [ "return" ], "mappings": "AAAAA,SAAA;AAAA,SAAAA" }