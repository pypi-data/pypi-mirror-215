// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.13.0
// source: cmon.proto

package cmon_go_proto

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CmonDataRequestRPCClient is the client API for CmonDataRequestRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonDataRequestRPCClient interface {
	// Used for passing DataRequests to the Executors
	ProcessData(ctx context.Context, in *DataRequestListProto, opts ...grpc.CallOption) (*DataRequestProto, error)
}

type cmonDataRequestRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonDataRequestRPCClient(cc grpc.ClientConnInterface) CmonDataRequestRPCClient {
	return &cmonDataRequestRPCClient{cc}
}

func (c *cmonDataRequestRPCClient) ProcessData(ctx context.Context, in *DataRequestListProto, opts ...grpc.CallOption) (*DataRequestProto, error) {
	out := new(DataRequestProto)
	err := c.cc.Invoke(ctx, "/cmon.CmonDataRequestRPC/process_data", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmonDataRequestRPCServer is the server API for CmonDataRequestRPC service.
// All implementations must embed UnimplementedCmonDataRequestRPCServer
// for forward compatibility
type CmonDataRequestRPCServer interface {
	// Used for passing DataRequests to the Executors
	ProcessData(context.Context, *DataRequestListProto) (*DataRequestProto, error)
	mustEmbedUnimplementedCmonDataRequestRPCServer()
}

// UnimplementedCmonDataRequestRPCServer must be embedded to have forward compatible implementations.
type UnimplementedCmonDataRequestRPCServer struct {
}

func (UnimplementedCmonDataRequestRPCServer) ProcessData(context.Context, *DataRequestListProto) (*DataRequestProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessData not implemented")
}
func (UnimplementedCmonDataRequestRPCServer) mustEmbedUnimplementedCmonDataRequestRPCServer() {}

// UnsafeCmonDataRequestRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonDataRequestRPCServer will
// result in compilation errors.
type UnsafeCmonDataRequestRPCServer interface {
	mustEmbedUnimplementedCmonDataRequestRPCServer()
}

func RegisterCmonDataRequestRPCServer(s grpc.ServiceRegistrar, srv CmonDataRequestRPCServer) {
	s.RegisterService(&CmonDataRequestRPC_ServiceDesc, srv)
}

func _CmonDataRequestRPC_ProcessData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataRequestListProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmonDataRequestRPCServer).ProcessData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmon.CmonDataRequestRPC/process_data",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmonDataRequestRPCServer).ProcessData(ctx, req.(*DataRequestListProto))
	}
	return interceptor(ctx, in, info, handler)
}

// CmonDataRequestRPC_ServiceDesc is the grpc.ServiceDesc for CmonDataRequestRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonDataRequestRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonDataRequestRPC",
	HandlerType: (*CmonDataRequestRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "process_data",
			Handler:    _CmonDataRequestRPC_ProcessData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cmon.proto",
}

// CmonSingleDataRequestRPCClient is the client API for CmonSingleDataRequestRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonSingleDataRequestRPCClient interface {
	// Used for passing DataRequests to the Executors
	ProcessSingleData(ctx context.Context, in *DataRequestProto, opts ...grpc.CallOption) (*DataRequestProto, error)
}

type cmonSingleDataRequestRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonSingleDataRequestRPCClient(cc grpc.ClientConnInterface) CmonSingleDataRequestRPCClient {
	return &cmonSingleDataRequestRPCClient{cc}
}

func (c *cmonSingleDataRequestRPCClient) ProcessSingleData(ctx context.Context, in *DataRequestProto, opts ...grpc.CallOption) (*DataRequestProto, error) {
	out := new(DataRequestProto)
	err := c.cc.Invoke(ctx, "/cmon.CmonSingleDataRequestRPC/process_single_data", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmonSingleDataRequestRPCServer is the server API for CmonSingleDataRequestRPC service.
// All implementations must embed UnimplementedCmonSingleDataRequestRPCServer
// for forward compatibility
type CmonSingleDataRequestRPCServer interface {
	// Used for passing DataRequests to the Executors
	ProcessSingleData(context.Context, *DataRequestProto) (*DataRequestProto, error)
	mustEmbedUnimplementedCmonSingleDataRequestRPCServer()
}

// UnimplementedCmonSingleDataRequestRPCServer must be embedded to have forward compatible implementations.
type UnimplementedCmonSingleDataRequestRPCServer struct {
}

func (UnimplementedCmonSingleDataRequestRPCServer) ProcessSingleData(context.Context, *DataRequestProto) (*DataRequestProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessSingleData not implemented")
}
func (UnimplementedCmonSingleDataRequestRPCServer) mustEmbedUnimplementedCmonSingleDataRequestRPCServer() {
}

// UnsafeCmonSingleDataRequestRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonSingleDataRequestRPCServer will
// result in compilation errors.
type UnsafeCmonSingleDataRequestRPCServer interface {
	mustEmbedUnimplementedCmonSingleDataRequestRPCServer()
}

func RegisterCmonSingleDataRequestRPCServer(s grpc.ServiceRegistrar, srv CmonSingleDataRequestRPCServer) {
	s.RegisterService(&CmonSingleDataRequestRPC_ServiceDesc, srv)
}

func _CmonSingleDataRequestRPC_ProcessSingleData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmonSingleDataRequestRPCServer).ProcessSingleData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmon.CmonSingleDataRequestRPC/process_single_data",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmonSingleDataRequestRPCServer).ProcessSingleData(ctx, req.(*DataRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

// CmonSingleDataRequestRPC_ServiceDesc is the grpc.ServiceDesc for CmonSingleDataRequestRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonSingleDataRequestRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonSingleDataRequestRPC",
	HandlerType: (*CmonSingleDataRequestRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "process_single_data",
			Handler:    _CmonSingleDataRequestRPC_ProcessSingleData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cmon.proto",
}

// CmonRPCClient is the client API for CmonRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonRPCClient interface {
	// Pass in a Request and a filled Request with matches will be returned.
	Call(ctx context.Context, opts ...grpc.CallOption) (CmonRPC_CallClient, error)
}

type cmonRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonRPCClient(cc grpc.ClientConnInterface) CmonRPCClient {
	return &cmonRPCClient{cc}
}

func (c *cmonRPCClient) Call(ctx context.Context, opts ...grpc.CallOption) (CmonRPC_CallClient, error) {
	stream, err := c.cc.NewStream(ctx, &CmonRPC_ServiceDesc.Streams[0], "/cmon.CmonRPC/Call", opts...)
	if err != nil {
		return nil, err
	}
	x := &cmonRPCCallClient{stream}
	return x, nil
}

type CmonRPC_CallClient interface {
	Send(*DataRequestProto) error
	Recv() (*DataRequestProto, error)
	grpc.ClientStream
}

type cmonRPCCallClient struct {
	grpc.ClientStream
}

func (x *cmonRPCCallClient) Send(m *DataRequestProto) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cmonRPCCallClient) Recv() (*DataRequestProto, error) {
	m := new(DataRequestProto)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CmonRPCServer is the server API for CmonRPC service.
// All implementations must embed UnimplementedCmonRPCServer
// for forward compatibility
type CmonRPCServer interface {
	// Pass in a Request and a filled Request with matches will be returned.
	Call(CmonRPC_CallServer) error
	mustEmbedUnimplementedCmonRPCServer()
}

// UnimplementedCmonRPCServer must be embedded to have forward compatible implementations.
type UnimplementedCmonRPCServer struct {
}

func (UnimplementedCmonRPCServer) Call(CmonRPC_CallServer) error {
	return status.Errorf(codes.Unimplemented, "method Call not implemented")
}
func (UnimplementedCmonRPCServer) mustEmbedUnimplementedCmonRPCServer() {}

// UnsafeCmonRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonRPCServer will
// result in compilation errors.
type UnsafeCmonRPCServer interface {
	mustEmbedUnimplementedCmonRPCServer()
}

func RegisterCmonRPCServer(s grpc.ServiceRegistrar, srv CmonRPCServer) {
	s.RegisterService(&CmonRPC_ServiceDesc, srv)
}

func _CmonRPC_Call_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CmonRPCServer).Call(&cmonRPCCallServer{stream})
}

type CmonRPC_CallServer interface {
	Send(*DataRequestProto) error
	Recv() (*DataRequestProto, error)
	grpc.ServerStream
}

type cmonRPCCallServer struct {
	grpc.ServerStream
}

func (x *cmonRPCCallServer) Send(m *DataRequestProto) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cmonRPCCallServer) Recv() (*DataRequestProto, error) {
	m := new(DataRequestProto)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CmonRPC_ServiceDesc is the grpc.ServiceDesc for CmonRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonRPC",
	HandlerType: (*CmonRPCServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Call",
			Handler:       _CmonRPC_Call_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cmon.proto",
}

// CmonDiscoverEndpointsRPCClient is the client API for CmonDiscoverEndpointsRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonDiscoverEndpointsRPCClient interface {
	EndpointDiscovery(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*EndpointsProto, error)
}

type cmonDiscoverEndpointsRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonDiscoverEndpointsRPCClient(cc grpc.ClientConnInterface) CmonDiscoverEndpointsRPCClient {
	return &cmonDiscoverEndpointsRPCClient{cc}
}

func (c *cmonDiscoverEndpointsRPCClient) EndpointDiscovery(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*EndpointsProto, error) {
	out := new(EndpointsProto)
	err := c.cc.Invoke(ctx, "/cmon.CmonDiscoverEndpointsRPC/endpoint_discovery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmonDiscoverEndpointsRPCServer is the server API for CmonDiscoverEndpointsRPC service.
// All implementations must embed UnimplementedCmonDiscoverEndpointsRPCServer
// for forward compatibility
type CmonDiscoverEndpointsRPCServer interface {
	EndpointDiscovery(context.Context, *empty.Empty) (*EndpointsProto, error)
	mustEmbedUnimplementedCmonDiscoverEndpointsRPCServer()
}

// UnimplementedCmonDiscoverEndpointsRPCServer must be embedded to have forward compatible implementations.
type UnimplementedCmonDiscoverEndpointsRPCServer struct {
}

func (UnimplementedCmonDiscoverEndpointsRPCServer) EndpointDiscovery(context.Context, *empty.Empty) (*EndpointsProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndpointDiscovery not implemented")
}
func (UnimplementedCmonDiscoverEndpointsRPCServer) mustEmbedUnimplementedCmonDiscoverEndpointsRPCServer() {
}

// UnsafeCmonDiscoverEndpointsRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonDiscoverEndpointsRPCServer will
// result in compilation errors.
type UnsafeCmonDiscoverEndpointsRPCServer interface {
	mustEmbedUnimplementedCmonDiscoverEndpointsRPCServer()
}

func RegisterCmonDiscoverEndpointsRPCServer(s grpc.ServiceRegistrar, srv CmonDiscoverEndpointsRPCServer) {
	s.RegisterService(&CmonDiscoverEndpointsRPC_ServiceDesc, srv)
}

func _CmonDiscoverEndpointsRPC_EndpointDiscovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmonDiscoverEndpointsRPCServer).EndpointDiscovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmon.CmonDiscoverEndpointsRPC/endpoint_discovery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmonDiscoverEndpointsRPCServer).EndpointDiscovery(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CmonDiscoverEndpointsRPC_ServiceDesc is the grpc.ServiceDesc for CmonDiscoverEndpointsRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonDiscoverEndpointsRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonDiscoverEndpointsRPC",
	HandlerType: (*CmonDiscoverEndpointsRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "endpoint_discovery",
			Handler:    _CmonDiscoverEndpointsRPC_EndpointDiscovery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cmon.proto",
}

// CmonGatewayDryRunRPCClient is the client API for CmonGatewayDryRunRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonGatewayDryRunRPCClient interface {
	DryRun(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*StatusProto, error)
}

type cmonGatewayDryRunRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonGatewayDryRunRPCClient(cc grpc.ClientConnInterface) CmonGatewayDryRunRPCClient {
	return &cmonGatewayDryRunRPCClient{cc}
}

func (c *cmonGatewayDryRunRPCClient) DryRun(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*StatusProto, error) {
	out := new(StatusProto)
	err := c.cc.Invoke(ctx, "/cmon.CmonGatewayDryRunRPC/dry_run", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmonGatewayDryRunRPCServer is the server API for CmonGatewayDryRunRPC service.
// All implementations must embed UnimplementedCmonGatewayDryRunRPCServer
// for forward compatibility
type CmonGatewayDryRunRPCServer interface {
	DryRun(context.Context, *empty.Empty) (*StatusProto, error)
	mustEmbedUnimplementedCmonGatewayDryRunRPCServer()
}

// UnimplementedCmonGatewayDryRunRPCServer must be embedded to have forward compatible implementations.
type UnimplementedCmonGatewayDryRunRPCServer struct {
}

func (UnimplementedCmonGatewayDryRunRPCServer) DryRun(context.Context, *empty.Empty) (*StatusProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DryRun not implemented")
}
func (UnimplementedCmonGatewayDryRunRPCServer) mustEmbedUnimplementedCmonGatewayDryRunRPCServer() {}

// UnsafeCmonGatewayDryRunRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonGatewayDryRunRPCServer will
// result in compilation errors.
type UnsafeCmonGatewayDryRunRPCServer interface {
	mustEmbedUnimplementedCmonGatewayDryRunRPCServer()
}

func RegisterCmonGatewayDryRunRPCServer(s grpc.ServiceRegistrar, srv CmonGatewayDryRunRPCServer) {
	s.RegisterService(&CmonGatewayDryRunRPC_ServiceDesc, srv)
}

func _CmonGatewayDryRunRPC_DryRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmonGatewayDryRunRPCServer).DryRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmon.CmonGatewayDryRunRPC/dry_run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmonGatewayDryRunRPCServer).DryRun(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CmonGatewayDryRunRPC_ServiceDesc is the grpc.ServiceDesc for CmonGatewayDryRunRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonGatewayDryRunRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonGatewayDryRunRPC",
	HandlerType: (*CmonGatewayDryRunRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "dry_run",
			Handler:    _CmonGatewayDryRunRPC_DryRun_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cmon.proto",
}

// CmonInfoRPCClient is the client API for CmonInfoRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonInfoRPCClient interface {
	XStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CmonInfoProto, error)
}

type cmonInfoRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonInfoRPCClient(cc grpc.ClientConnInterface) CmonInfoRPCClient {
	return &cmonInfoRPCClient{cc}
}

func (c *cmonInfoRPCClient) XStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CmonInfoProto, error) {
	out := new(CmonInfoProto)
	err := c.cc.Invoke(ctx, "/cmon.CmonInfoRPC/_status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmonInfoRPCServer is the server API for CmonInfoRPC service.
// All implementations must embed UnimplementedCmonInfoRPCServer
// for forward compatibility
type CmonInfoRPCServer interface {
	XStatus(context.Context, *empty.Empty) (*CmonInfoProto, error)
	mustEmbedUnimplementedCmonInfoRPCServer()
}

// UnimplementedCmonInfoRPCServer must be embedded to have forward compatible implementations.
type UnimplementedCmonInfoRPCServer struct {
}

func (UnimplementedCmonInfoRPCServer) XStatus(context.Context, *empty.Empty) (*CmonInfoProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method XStatus not implemented")
}
func (UnimplementedCmonInfoRPCServer) mustEmbedUnimplementedCmonInfoRPCServer() {}

// UnsafeCmonInfoRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonInfoRPCServer will
// result in compilation errors.
type UnsafeCmonInfoRPCServer interface {
	mustEmbedUnimplementedCmonInfoRPCServer()
}

func RegisterCmonInfoRPCServer(s grpc.ServiceRegistrar, srv CmonInfoRPCServer) {
	s.RegisterService(&CmonInfoRPC_ServiceDesc, srv)
}

func _CmonInfoRPC_XStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmonInfoRPCServer).XStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmon.CmonInfoRPC/_status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmonInfoRPCServer).XStatus(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CmonInfoRPC_ServiceDesc is the grpc.ServiceDesc for CmonInfoRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonInfoRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonInfoRPC",
	HandlerType: (*CmonInfoRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "_status",
			Handler:    _CmonInfoRPC_XStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cmon.proto",
}

// CmonExecutorSnapshotClient is the client API for CmonExecutorSnapshot service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonExecutorSnapshotClient interface {
	Snapshot(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SnapshotStatusProto, error)
}

type cmonExecutorSnapshotClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonExecutorSnapshotClient(cc grpc.ClientConnInterface) CmonExecutorSnapshotClient {
	return &cmonExecutorSnapshotClient{cc}
}

func (c *cmonExecutorSnapshotClient) Snapshot(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SnapshotStatusProto, error) {
	out := new(SnapshotStatusProto)
	err := c.cc.Invoke(ctx, "/cmon.CmonExecutorSnapshot/snapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmonExecutorSnapshotServer is the server API for CmonExecutorSnapshot service.
// All implementations must embed UnimplementedCmonExecutorSnapshotServer
// for forward compatibility
type CmonExecutorSnapshotServer interface {
	Snapshot(context.Context, *empty.Empty) (*SnapshotStatusProto, error)
	mustEmbedUnimplementedCmonExecutorSnapshotServer()
}

// UnimplementedCmonExecutorSnapshotServer must be embedded to have forward compatible implementations.
type UnimplementedCmonExecutorSnapshotServer struct {
}

func (UnimplementedCmonExecutorSnapshotServer) Snapshot(context.Context, *empty.Empty) (*SnapshotStatusProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Snapshot not implemented")
}
func (UnimplementedCmonExecutorSnapshotServer) mustEmbedUnimplementedCmonExecutorSnapshotServer() {}

// UnsafeCmonExecutorSnapshotServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonExecutorSnapshotServer will
// result in compilation errors.
type UnsafeCmonExecutorSnapshotServer interface {
	mustEmbedUnimplementedCmonExecutorSnapshotServer()
}

func RegisterCmonExecutorSnapshotServer(s grpc.ServiceRegistrar, srv CmonExecutorSnapshotServer) {
	s.RegisterService(&CmonExecutorSnapshot_ServiceDesc, srv)
}

func _CmonExecutorSnapshot_Snapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmonExecutorSnapshotServer).Snapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmon.CmonExecutorSnapshot/snapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmonExecutorSnapshotServer).Snapshot(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CmonExecutorSnapshot_ServiceDesc is the grpc.ServiceDesc for CmonExecutorSnapshot service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonExecutorSnapshot_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonExecutorSnapshot",
	HandlerType: (*CmonExecutorSnapshotServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "snapshot",
			Handler:    _CmonExecutorSnapshot_Snapshot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cmon.proto",
}

// CmonExecutorSnapshotProgressClient is the client API for CmonExecutorSnapshotProgress service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonExecutorSnapshotProgressClient interface {
	SnapshotStatus(ctx context.Context, in *SnapshotId, opts ...grpc.CallOption) (*SnapshotStatusProto, error)
}

type cmonExecutorSnapshotProgressClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonExecutorSnapshotProgressClient(cc grpc.ClientConnInterface) CmonExecutorSnapshotProgressClient {
	return &cmonExecutorSnapshotProgressClient{cc}
}

func (c *cmonExecutorSnapshotProgressClient) SnapshotStatus(ctx context.Context, in *SnapshotId, opts ...grpc.CallOption) (*SnapshotStatusProto, error) {
	out := new(SnapshotStatusProto)
	err := c.cc.Invoke(ctx, "/cmon.CmonExecutorSnapshotProgress/snapshot_status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmonExecutorSnapshotProgressServer is the server API for CmonExecutorSnapshotProgress service.
// All implementations must embed UnimplementedCmonExecutorSnapshotProgressServer
// for forward compatibility
type CmonExecutorSnapshotProgressServer interface {
	SnapshotStatus(context.Context, *SnapshotId) (*SnapshotStatusProto, error)
	mustEmbedUnimplementedCmonExecutorSnapshotProgressServer()
}

// UnimplementedCmonExecutorSnapshotProgressServer must be embedded to have forward compatible implementations.
type UnimplementedCmonExecutorSnapshotProgressServer struct {
}

func (UnimplementedCmonExecutorSnapshotProgressServer) SnapshotStatus(context.Context, *SnapshotId) (*SnapshotStatusProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SnapshotStatus not implemented")
}
func (UnimplementedCmonExecutorSnapshotProgressServer) mustEmbedUnimplementedCmonExecutorSnapshotProgressServer() {
}

// UnsafeCmonExecutorSnapshotProgressServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonExecutorSnapshotProgressServer will
// result in compilation errors.
type UnsafeCmonExecutorSnapshotProgressServer interface {
	mustEmbedUnimplementedCmonExecutorSnapshotProgressServer()
}

func RegisterCmonExecutorSnapshotProgressServer(s grpc.ServiceRegistrar, srv CmonExecutorSnapshotProgressServer) {
	s.RegisterService(&CmonExecutorSnapshotProgress_ServiceDesc, srv)
}

func _CmonExecutorSnapshotProgress_SnapshotStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SnapshotId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmonExecutorSnapshotProgressServer).SnapshotStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmon.CmonExecutorSnapshotProgress/snapshot_status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmonExecutorSnapshotProgressServer).SnapshotStatus(ctx, req.(*SnapshotId))
	}
	return interceptor(ctx, in, info, handler)
}

// CmonExecutorSnapshotProgress_ServiceDesc is the grpc.ServiceDesc for CmonExecutorSnapshotProgress service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonExecutorSnapshotProgress_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonExecutorSnapshotProgress",
	HandlerType: (*CmonExecutorSnapshotProgressServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "snapshot_status",
			Handler:    _CmonExecutorSnapshotProgress_SnapshotStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cmon.proto",
}

// CmonExecutorRestoreClient is the client API for CmonExecutorRestore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonExecutorRestoreClient interface {
	Restore(ctx context.Context, in *RestoreSnapshotCommand, opts ...grpc.CallOption) (*RestoreSnapshotStatusProto, error)
}

type cmonExecutorRestoreClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonExecutorRestoreClient(cc grpc.ClientConnInterface) CmonExecutorRestoreClient {
	return &cmonExecutorRestoreClient{cc}
}

func (c *cmonExecutorRestoreClient) Restore(ctx context.Context, in *RestoreSnapshotCommand, opts ...grpc.CallOption) (*RestoreSnapshotStatusProto, error) {
	out := new(RestoreSnapshotStatusProto)
	err := c.cc.Invoke(ctx, "/cmon.CmonExecutorRestore/restore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmonExecutorRestoreServer is the server API for CmonExecutorRestore service.
// All implementations must embed UnimplementedCmonExecutorRestoreServer
// for forward compatibility
type CmonExecutorRestoreServer interface {
	Restore(context.Context, *RestoreSnapshotCommand) (*RestoreSnapshotStatusProto, error)
	mustEmbedUnimplementedCmonExecutorRestoreServer()
}

// UnimplementedCmonExecutorRestoreServer must be embedded to have forward compatible implementations.
type UnimplementedCmonExecutorRestoreServer struct {
}

func (UnimplementedCmonExecutorRestoreServer) Restore(context.Context, *RestoreSnapshotCommand) (*RestoreSnapshotStatusProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restore not implemented")
}
func (UnimplementedCmonExecutorRestoreServer) mustEmbedUnimplementedCmonExecutorRestoreServer() {}

// UnsafeCmonExecutorRestoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonExecutorRestoreServer will
// result in compilation errors.
type UnsafeCmonExecutorRestoreServer interface {
	mustEmbedUnimplementedCmonExecutorRestoreServer()
}

func RegisterCmonExecutorRestoreServer(s grpc.ServiceRegistrar, srv CmonExecutorRestoreServer) {
	s.RegisterService(&CmonExecutorRestore_ServiceDesc, srv)
}

func _CmonExecutorRestore_Restore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreSnapshotCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmonExecutorRestoreServer).Restore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmon.CmonExecutorRestore/restore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmonExecutorRestoreServer).Restore(ctx, req.(*RestoreSnapshotCommand))
	}
	return interceptor(ctx, in, info, handler)
}

// CmonExecutorRestore_ServiceDesc is the grpc.ServiceDesc for CmonExecutorRestore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonExecutorRestore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonExecutorRestore",
	HandlerType: (*CmonExecutorRestoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "restore",
			Handler:    _CmonExecutorRestore_Restore_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cmon.proto",
}

// CmonExecutorRestoreProgressClient is the client API for CmonExecutorRestoreProgress service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmonExecutorRestoreProgressClient interface {
	RestoreStatus(ctx context.Context, in *RestoreId, opts ...grpc.CallOption) (*RestoreSnapshotStatusProto, error)
}

type cmonExecutorRestoreProgressClient struct {
	cc grpc.ClientConnInterface
}

func NewCmonExecutorRestoreProgressClient(cc grpc.ClientConnInterface) CmonExecutorRestoreProgressClient {
	return &cmonExecutorRestoreProgressClient{cc}
}

func (c *cmonExecutorRestoreProgressClient) RestoreStatus(ctx context.Context, in *RestoreId, opts ...grpc.CallOption) (*RestoreSnapshotStatusProto, error) {
	out := new(RestoreSnapshotStatusProto)
	err := c.cc.Invoke(ctx, "/cmon.CmonExecutorRestoreProgress/restore_status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmonExecutorRestoreProgressServer is the server API for CmonExecutorRestoreProgress service.
// All implementations must embed UnimplementedCmonExecutorRestoreProgressServer
// for forward compatibility
type CmonExecutorRestoreProgressServer interface {
	RestoreStatus(context.Context, *RestoreId) (*RestoreSnapshotStatusProto, error)
	mustEmbedUnimplementedCmonExecutorRestoreProgressServer()
}

// UnimplementedCmonExecutorRestoreProgressServer must be embedded to have forward compatible implementations.
type UnimplementedCmonExecutorRestoreProgressServer struct {
}

func (UnimplementedCmonExecutorRestoreProgressServer) RestoreStatus(context.Context, *RestoreId) (*RestoreSnapshotStatusProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreStatus not implemented")
}
func (UnimplementedCmonExecutorRestoreProgressServer) mustEmbedUnimplementedCmonExecutorRestoreProgressServer() {
}

// UnsafeCmonExecutorRestoreProgressServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmonExecutorRestoreProgressServer will
// result in compilation errors.
type UnsafeCmonExecutorRestoreProgressServer interface {
	mustEmbedUnimplementedCmonExecutorRestoreProgressServer()
}

func RegisterCmonExecutorRestoreProgressServer(s grpc.ServiceRegistrar, srv CmonExecutorRestoreProgressServer) {
	s.RegisterService(&CmonExecutorRestoreProgress_ServiceDesc, srv)
}

func _CmonExecutorRestoreProgress_RestoreStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmonExecutorRestoreProgressServer).RestoreStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmon.CmonExecutorRestoreProgress/restore_status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmonExecutorRestoreProgressServer).RestoreStatus(ctx, req.(*RestoreId))
	}
	return interceptor(ctx, in, info, handler)
}

// CmonExecutorRestoreProgress_ServiceDesc is the grpc.ServiceDesc for CmonExecutorRestoreProgress service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmonExecutorRestoreProgress_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmon.CmonExecutorRestoreProgress",
	HandlerType: (*CmonExecutorRestoreProgressServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "restore_status",
			Handler:    _CmonExecutorRestoreProgress_RestoreStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cmon.proto",
}
