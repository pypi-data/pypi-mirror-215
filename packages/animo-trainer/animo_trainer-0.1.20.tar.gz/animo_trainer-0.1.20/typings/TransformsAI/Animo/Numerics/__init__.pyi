import typing, clr, abc
from System.Numerics import Vector3, Vector2
from System import IFormattable, IEquatable_1, IFormatProvider, Array_1

class MathHelpers(abc.ABC):
    @staticmethod
    def IsValidYDelta(a: Vector3Int, b: Vector3Int, maxDelta: int = ...) -> bool: ...
    @staticmethod
    def NormalizedSafe(v: Vector3) -> Vector3: ...
    @staticmethod
    def RoundToInt(v: Vector3) -> Vector3Int: ...
    @staticmethod
    def ToUnitDirection(v1: Vector3) -> Vector3Int: ...


class Vector2Int(IFormattable, IEquatable_1[Vector2Int]):
    def __init__(self, x: int, y: int) -> None: ...
    X : int
    Y : int
    @classmethod
    @property
    def Down(cls) -> Vector2Int: ...
    @property
    def Item(self) -> int: ...
    @Item.setter
    def Item(self, value: int) -> int: ...
    @classmethod
    @property
    def Left(cls) -> Vector2Int: ...
    @property
    def m_X(self) -> None: ...
    @m_X.setter
    def m_X(self, value: int) -> None: ...
    @property
    def m_Y(self) -> None: ...
    @m_Y.setter
    def m_Y(self, value: int) -> None: ...
    @property
    def Magnitude(self) -> float: ...
    @classmethod
    @property
    def One(cls) -> Vector2Int: ...
    @classmethod
    @property
    def Right(cls) -> Vector2Int: ...
    @property
    def SqrMagnitude(self) -> int: ...
    @classmethod
    @property
    def Up(cls) -> Vector2Int: ...
    @classmethod
    @property
    def Zero(cls) -> Vector2Int: ...
    @staticmethod
    def CeilToInt(v: Vector2) -> Vector2Int: ...
    def Clamp(self, min: Vector2Int, max: Vector2Int) -> None: ...
    def Deconstruct(self, x: clr.Reference[int], y: clr.Reference[int]) -> None: ...
    @staticmethod
    def Distance(a: Vector2Int, b: Vector2Int) -> float: ...
    @staticmethod
    def FloorToInt(v: Vector2) -> Vector2Int: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def ManhattanDistance(a: Vector2Int, b: Vector2Int) -> int: ...
    @staticmethod
    def Max(lhs: Vector2Int, rhs: Vector2Int) -> Vector2Int: ...
    @staticmethod
    def Min(lhs: Vector2Int, rhs: Vector2Int) -> Vector2Int: ...
    def __add__(self, a: Vector2Int, b: Vector2Int) -> Vector2Int: ...
    def __truediv__(self, a: Vector2Int, b: int) -> Vector2Int: ...
    def __eq__(self, lhs: Vector2Int, rhs: Vector2Int) -> bool: ...
    # Operator not supported op_Explicit(v: Vector2Int)
    # Operator not supported op_Implicit(v: Vector2Int)
    def __ne__(self, lhs: Vector2Int, rhs: Vector2Int) -> bool: ...
    @typing.overload
    def __mul__(self, a: int, b: Vector2Int) -> Vector2Int: ...
    @typing.overload
    def __mul__(self, a: Vector2Int, b: int) -> Vector2Int: ...
    @typing.overload
    def __mul__(self, a: Vector2Int, b: Vector2Int) -> Vector2Int: ...
    def __sub__(self, a: Vector2Int, b: Vector2Int) -> Vector2Int: ...
    def __neg__(self, v: Vector2Int) -> Vector2Int: ...
    def Rotate(self, angle: float) -> Vector2Int: ...
    @staticmethod
    def RoundToInt(v: Vector2) -> Vector2Int: ...
    def ToVector3IntXZ(self) -> Vector3Int: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vector2Int) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Scale due to it being static, abstract and generic.

    Scale : Scale_MethodGroup
    class Scale_MethodGroup:
        @typing.overload
        def __call__(self, scale: Vector2Int) -> None:...
        @typing.overload
        def __call__(self, a: Vector2Int, b: Vector2Int) -> Vector2Int:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class Vector3Int(IFormattable, IEquatable_1[Vector3Int]):
    def __init__(self, x: int, y: int, z: int) -> None: ...
    AdjacentDirectionsXZ : Array_1[Vector3Int]
    UnitDirectionsXZ : Array_1[Vector3Int]
    X : int
    Y : int
    Z : int
    @classmethod
    @property
    def Back(cls) -> Vector3Int: ...
    @classmethod
    @property
    def Down(cls) -> Vector3Int: ...
    @classmethod
    @property
    def Forward(cls) -> Vector3Int: ...
    @property
    def Item(self) -> int: ...
    @Item.setter
    def Item(self, value: int) -> int: ...
    @classmethod
    @property
    def Left(cls) -> Vector3Int: ...
    @property
    def m_X(self) -> None: ...
    @m_X.setter
    def m_X(self, value: int) -> None: ...
    @property
    def m_Y(self) -> None: ...
    @m_Y.setter
    def m_Y(self, value: int) -> None: ...
    @property
    def m_Z(self) -> None: ...
    @m_Z.setter
    def m_Z(self, value: int) -> None: ...
    @property
    def Magnitude(self) -> float: ...
    @classmethod
    @property
    def One(cls) -> Vector3Int: ...
    @classmethod
    @property
    def Right(cls) -> Vector3Int: ...
    @property
    def SqrMagnitude(self) -> int: ...
    @classmethod
    @property
    def Up(cls) -> Vector3Int: ...
    @classmethod
    @property
    def Zero(cls) -> Vector3Int: ...
    @staticmethod
    def CeilToInt(v: Vector3) -> Vector3Int: ...
    def Clamp(self, min: Vector3Int, max: Vector3Int) -> None: ...
    def ClampBounds(self, max: int) -> Vector3Int: ...
    def Deconstruct(self, x: clr.Reference[int], y: clr.Reference[int], z: clr.Reference[int]) -> None: ...
    @staticmethod
    def Distance(a: Vector3Int, b: Vector3Int) -> float: ...
    @staticmethod
    def FloorToInt(v: Vector3) -> Vector3Int: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Max(lhs: Vector3Int, rhs: Vector3Int) -> Vector3Int: ...
    @staticmethod
    def Min(lhs: Vector3Int, rhs: Vector3Int) -> Vector3Int: ...
    def MinComponent(self) -> int: ...
    def NormalizedSafe(self) -> Vector3: ...
    def __add__(self, a: Vector3Int, b: Vector3Int) -> Vector3Int: ...
    def __truediv__(self, a: Vector3Int, b: int) -> Vector3Int: ...
    def __eq__(self, lhs: Vector3Int, rhs: Vector3Int) -> bool: ...
    # Operator not supported op_Explicit(v: Vector3Int)
    # Operator not supported op_Implicit(v: Vector3Int)
    def __ne__(self, lhs: Vector3Int, rhs: Vector3Int) -> bool: ...
    @typing.overload
    def __mul__(self, a: int, b: Vector3Int) -> Vector3Int: ...
    @typing.overload
    def __mul__(self, a: Vector3Int, b: int) -> Vector3Int: ...
    @typing.overload
    def __mul__(self, a: Vector3Int, b: Vector3Int) -> Vector3Int: ...
    def __sub__(self, a: Vector3Int, b: Vector3Int) -> Vector3Int: ...
    def __neg__(self, a: Vector3Int) -> Vector3Int: ...
    @staticmethod
    def RoundToInt(v: Vector3) -> Vector3Int: ...
    def ToUnitDirection(self) -> Vector3Int: ...
    def WithX(self, newX: int) -> Vector3Int: ...
    def WithY(self, newY: int) -> Vector3Int: ...
    def WithZ(self, newZ: int) -> Vector3Int: ...
    @staticmethod
    def XDelta(a: Vector3Int, b: Vector3Int) -> int: ...
    def XZ(self) -> Vector2Int: ...
    @staticmethod
    def YDelta(a: Vector3Int, b: Vector3Int) -> int: ...
    @staticmethod
    def ZDelta(a: Vector3Int, b: Vector3Int) -> int: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vector3Int) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...

    # Skipped Scale due to it being static, abstract and generic.

    Scale : Scale_MethodGroup
    class Scale_MethodGroup:
        @typing.overload
        def __call__(self, scale: Vector3Int) -> None:...
        @typing.overload
        def __call__(self, a: Vector3Int, b: Vector3Int) -> Vector3Int:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...


