import unittest
import os
from pathlib import Path
import matplotlib.pyplot as plt
import numpy as np

from steam_sdk.builders.BuilderLEDET import BuilderLEDET
from steam_sdk.builders.BuilderModel import BuilderModel
from steam_sdk.parsers.ParserLEDET import CompareLEDETParameters, ParserLEDET, check_for_differences
from steam_sdk.parsers.ParserProteCCT import CompareProteCCTParameters
from steam_sdk.parsers.ParserMap2d import parseRoxieMap2d
from tests.TestHelpers import assert_equal_yaml


class TestBuilderModel(unittest.TestCase):

    def setUp(self) -> None:
        """
            This function is executed before each test in this class
        """
        self.current_path = os.getcwd()
        os.chdir(os.path.dirname(__file__))  # move the directory where this file is located
        print('\nCurrent folder:          {}'.format(self.current_path))
        print('Test is run from folder: {}'.format(os.getcwd()))

    def tearDown(self) -> None:
        """
            This function is executed after each test in this class
        """
        os.chdir(self.current_path)  # go back to initial folder

        # Close all figures
        plt.close('all')

    def test_BuilderModel_initialization(self):
        """
            Check that BuilderData object can be initialized without providing any input
        """
        BuilderModel(file_model_data=None, software=None, flag_build=False, verbose=True)

    def test_BuilderModel_readYaml_REFERENCE(self):
        """
            Check that DataLEDET object can be initialized and can read the reference blank yaml file generated by DataModelMagnet()
        """
        # arrange
        name_reference_file = 'data_model_magnet_REFERENCE_default.yaml'
        file_path = os.path.dirname(__file__)  # path to the parent directory (with respect to this file)
        reference_file = os.path.join(os.path.dirname(file_path), 'data', 'references', name_reference_file)
        print("Selected reference_file: {}".format(reference_file))

        # act
        BM = BuilderModel(file_model_data=reference_file, software=None, flag_build=True, verbose=True)

        # assert
        # TODO: Add a sensible action to perform the test
        # This test is likely covered by ParserYaml test, consider removing.

    def test_BuilderModel_pathSettingsDefault(self):
        """
            Check that BuilderData object can be initialized and path_settings is set by default as expected
        """
        # arrange
        name_reference_file = 'data_model_magnet_REFERENCE_default.yaml'
        file_path = os.path.dirname(__file__)  # path to the parent directory (with respect to this file)
        reference_file = os.path.join(os.path.dirname(file_path), 'data', 'references', name_reference_file)

        path_current_folder = Path(os.getcwd())
        expected_path_settings = path_current_folder

        # act
        BM = BuilderModel(file_model_data=reference_file, software=None, flag_build=True, verbose=True)
        set_path_settings = BM.path_settings

        # assert
        self.assertEqual(expected_path_settings, set_path_settings)

    # def test_BuilderModel_pathSettingsParent(self):
    #     """
    #         Check that BuilderData object can be initialized and path_settings can be set to the parent folder
    #     """
    #     # arrange
    #     name_reference_file = 'data_model_magnet_REFERENCE.yaml'
    #     file_path = os.path.dirname(__file__)  # path to the parent directory (with respect to this file)
    #     reference_file = os.path.join(os.path.dirname(file_path), 'data', 'references', name_reference_file)
    #
    #     path_current_folder = Path(os.getcwd())
    #     expected_path_settings = path_current_folder.parent
    #
    #     # act
    #     BM = BuilderModel(file_model_data=reference_file, software=None, flag_build=True, verbose=True, relative_path_settings='../')
    #     set_path_settings = BM.path_settings
    #
    #     # assert
    #     self.assertEqual(expected_path_settings, set_path_settings)

    def test_BuilderModel_readYaml(self, magnet_name='MQXF_V2'):
        """
            Check that DataLEDET object can be initialized and can read a model input yaml file
            This test does not generate any output file
            magnet_name: can be any magnet name in the library
        """
        # arrange
        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', 'modelData_' + magnet_name + '.yaml')

        # act
        BM = BuilderModel(file_model_data=file_model_data, software=None, flag_build=True, verbose=True)

        # assert
        # TODO: Add a sensible action to perform the test

    def test_BuilderModel_FiQuS(self):
        """
            Check that BuilderModel object can be initialized, read a real model input yaml file, and generate a yaml
            file with all model data
        """
        # arrange
        magnet_names = ['MQXA', 'MBH_1in1', 'MCBRD']
        software = 'FiQuS'
        for name in magnet_names:
            file_model_data = os.path.join('model_library', 'magnets', name, 'input', f'modelData_{name}.yaml')
            output_path = os.path.join('model_library', 'magnets', name, 'output')

            # act
            BM = BuilderModel(file_model_data=file_model_data, software=[software], flag_build=True, output_path=output_path, verbose=True)

            # # assert
            file_extensions_to_test = BM.parser_FiQuS.file_exts
            output_files = [os.path.join(output_path, f'{name}_{software}.{ext}') for ext in file_extensions_to_test]
            reference_files = [os.path.join('references', 'magnets', name, f'{name}_{software}_REFERENCE.{ext}') for ext in file_extensions_to_test]

            for output_file, reference_file in zip(output_files, reference_files):
                print(f'Comparing: Output file: {output_file} with reference file: {reference_file}.')
                assert_equal_yaml(output_file, reference_file)

    def test_BuilderModel_SIGMA(self):
        """
            Check that BuilderModel object can be initialized, read a real model input yaml file, and generate a yaml
            file with all model data
        """
        # arrange
        magnet_names = ['MQXA']
        software = 'SIGMA'
        for name in magnet_names:
            file_model_data = os.path.join('model_library', 'magnets', name, 'input', f'modelData_{name}.yaml')
            output_path = os.path.join('model_library', 'magnets', name, 'output')

            # act
            BM = BuilderModel(file_model_data=file_model_data, software=[software], flag_build=True, output_path=output_path, verbose=True)

            # # assert
            file_extensions_to_test = BM.parser_SIGMA.file_exts
            output_files = [os.path.join(output_path, f'{name}_{software}.{ext}') for ext in file_extensions_to_test]
            reference_files = [os.path.join('references', 'magnets', name, f'{name}_{software}_REFERENCE.{ext}') for ext in file_extensions_to_test]

            for output_file, reference_file in zip(output_files, reference_files):
                print(f'Comparing: Output file: {output_file} with reference file: {reference_file}.')
                assert_equal_yaml(output_file, reference_file)

    def test_BuilderModel_LEDET_build_dump_all(self, magnet_name='MBRB'):
        """
            Check that BuilderModel object can be initialized, read a real model input yaml file, and generate a yaml
            file with all model data

            :param magnet_name: can be any magnet name in the library
        """
        # arrange
        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', 'modelData_' + magnet_name + '.yaml')
        dump_all_path = os.path.join('output', 'test_dump_all', magnet_name)
        output_path = os.path.join('output', 'test_dump_all', magnet_name)
        software = ['LEDET']

        # act
        BM = BuilderModel(file_model_data=file_model_data, software=software, flag_build=True, output_path=output_path,
                          flag_dump_all=True, dump_all_path=dump_all_path)

        # assert
        # TODO: Add the check that the generated yaml file is identical to a desired reference yaml file
        # TODO: Add similar check when other models are generated (other than LEDET)

    def test_BuilderModel_LEDET_CCT(self):
        magnet_names = ['MCBRD']  # this is a small subset of tests for a lean pipeline
        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=True, magnet_type='CCT_straight')

    def test_BuilderModel_LEDET_solenoid(self):
        magnet_names = ['MLEC']  # this is a small subset of tests for a lean pipeline
        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=True, magnet_type='solenoid')

    def test_BuilderModel_LEDET_multiple(self):
        # MQY_2in1 causes memory issues when run on Gitlab
        magnet_names_NOT_working_due_to_yamlInput = []
        magnet_names_NOT_working_due_to_RoxieParser = []
        magnet_names_working_but_test_on_gitlab_would_take_too_long = ['MCBYV_1AP', 'MCBCY_1AP', 'MCBCV_1AP', 'MCBH_1AP', 'MCBV_1AP', 'MCBCH_1AP', 'HEPDipo_4COILS', 'MU']
        magnet_names = ['MBRB', 'MQXF_V2', 'MQSX', 'MBRD', 'MBXF', 'MB_2COILS',
                        'MED_C_COMB', 'MO_1AP', 'MO', 'MS_1AP', 'MQT_1AP', 'MBH_1in1',
                        'MQTLH_1AP', 'MQTLI_1AP', 'MQS_1AP', 'MBRC',
                        'ERMC_V1', 'HEPDipo_4COILS', 'MCD', 'RMM_V1', 'MCBYH_1AP', 'MCS', 'MBX', 'MQXA',
                        'MBRS', 'MCBX_HV', 'MCBXH', 'MCBXV', 'CFD_600A',
                        'MQMC_2in1', 'MQM_2in1', 'MQML_2in1', 'MQ_1AP', 'MQXB', 'MQY_2in1', 'MCO', 'MCDO', 'MSS_1AP',
                        'SMC'
                        ]
        magnet_names = ['MBRB', 'MQXF_V2', 'MQSX', 'MO_1AP', 'FERMI_20T', 'SMC']  # this is a small subset of tests for a lean pipeline

        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=False)

    def test_BuilderModel_LEDET_multiple_QH_layers(self):
        magnet_names = ['dummy_MBH_2in1_with_multiple_QH']

        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=False)

    def test_BuilderModel_LEDET_json(self, magnet_name='MQXF_V2', max_relative_error=1E-5, verbose=True):
        """
            Check that BuilderModel object can be initialized, read a real model input yaml file, and generate a json
            file that can be used as a LEDET input file

            :param magnet_name: can be any magnet name in the library
        """
        # arrange
        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', 'modelData_' + magnet_name + '.yaml')
        output_path = os.path.join('output', 'test_json', magnet_name)
        software = ['LEDET']

        json_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, magnet_name + "_REFERENCE.json")
        json_file_GENERATED = os.path.join(output_path, magnet_name + ".json")

        # act
        BM = BuilderModel(file_model_data=file_model_data, software=software, flag_build=True, output_path=output_path, flag_json=True, verbose=False)

        # assert: read reference json file, read generaed json file, and compare them
        builder_ledet_ref = BuilderLEDET(flag_build=False)
        pl_ref = ParserLEDET(builder_ledet_ref)
        pl_ref.read_from_json(json_file_REFERENCE, verbose=True)

        builder_ledet_out = BuilderLEDET(flag_build=False)
        pl_out = ParserLEDET(builder_ledet_out)
        pl_out.read_from_json(json_file_GENERATED, verbose=True)

        print(check_for_differences(pl_ref, pl_out, max_relative_error=max_relative_error, verbose=verbose))
        print(pl_ref.builder_ledet.Inputs)
        print(pl_out.builder_ledet.Inputs)

        self.assertFalse(check_for_differences(pl_ref, pl_out, max_relative_error=max_relative_error, verbose=verbose))

    def test_BuilderModel_LEDET_plotAll(self, magnet_name='MBRD'):
        self._compare_to_reference_LEDET(magnet_name, verbose=False, flag_plot_all=True)

    def test_BuilderModel_ProteCCT(self):
        magnet_names = ['MCBRD']
        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_ProteCCT(magnet_name, verbose=False)

    def test_get_conductor_corners(self, magnet_name='MBRD'):
        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input',
                                       'modelData_' + magnet_name + '.yaml')
        output_path = os.path.join('model_library', 'magnets', magnet_name, 'output')
        BM = BuilderModel(file_model_data=file_model_data, software=['LEDET'], flag_build=True, flag_dump_all=False,
                          output_path=output_path, verbose=False, flag_plot_all=False)
        # RL = RoxieList(BM.roxie_data)
        # RL.x_insulated
        # RL.y_insulated
        # RL.x_bare
        # RL.y_bare
        # RL.i_conductor
        # RL.x_strand
        # RL.y_strand
        # RL.i_strand
        # RL.strand_to_halfTurn
        # TODO: Check that the corner position values are correct

    ###############################################################################################
    # Helper methods
    def _compare_to_reference_LEDET(self, magnet_name, verbose=False, flag_plot_all=False, magnet_type='multipole'):
        """
            Helper method called by other methods
            Check that BuilderModel object can be initialized, read a model input yaml file, and generate a LEDET model
            This test checks:
             - the content of the generated Excel file against a reference LEDET Excel file
             - the content of the generated csv file against a reference self-mutual inductance csv file
             - the content of the generated map2d file against a reference magnetic-field map map2d file

            magnet_name: can be any magnet name in the library
        """

        # arrange
        max_relative_error = 1e-6  # Maximum accepted relative error for excel, csv and map2d file comparison

        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', 'modelData_' + magnet_name + '.yaml')
        output_path = os.path.join('model_library', 'magnets', magnet_name, 'output')
        input_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, magnet_name + '_REFERENCE.xlsx')
        input_file_GENERATED = os.path.join('model_library', 'magnets', magnet_name, 'output', magnet_name + '.xlsx')

        if magnet_type != 'CCT_straight':  # check also .map2d and selfMutualInductanceMatrix.csv files for non CCT magnets

            csv_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, magnet_name + "_selfMutualInductanceMatrix_REFERENCE.csv")
            csv_file_GENERATED = os.path.join('model_library', 'magnets', magnet_name, 'output', magnet_name + "_selfMutualInductanceMatrix.csv")

            if magnet_name in ['MED_C_COMB']:
                suffix = '_All_WithIron_NoSelfField'
            else:
                suffix = '_All_WithIron_WithSelfField'
            if magnet_type == 'solenoid':
                suffix = '_All_NoIron_NoSelfField'

            map2d_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, magnet_name + suffix + "_REFERENCE.map2d")
            map2d_file_GENERATED = os.path.join('model_library', 'magnets', magnet_name, 'output', magnet_name + suffix + ".map2d")

        # act
        BM = BuilderModel(file_model_data=file_model_data, software=['LEDET'], flag_build=True, flag_dump_all=False,
                          output_path=output_path, verbose=verbose, flag_plot_all=flag_plot_all)

        # assert 1 - Check that the generated LEDET file has the same input as the reference
        self.assertTrue(CompareLEDETParameters(input_file_GENERATED,
                                                input_file_REFERENCE,
                                                max_relative_error=max_relative_error, verbose=verbose))

        if magnet_type != 'CCT_straight':  # check also .map2d and selfMutualInductanceMatrix.csv files for non CCT magnets

            # assert 2 - Check that the generated csv file differs from the reference by less than max_relative_error
            self._compare_two_csv_files(magnet_name, csv_file_REFERENCE, csv_file_GENERATED, max_relative_error=max_relative_error)

            # assert 3a - Check that the generated map2d file differs from the reference by less than max_relative_error
            values_REFERENCE = parseRoxieMap2d(map2d_file_REFERENCE, headerLines=1)
            values_GENERATED = parseRoxieMap2d(map2d_file_GENERATED, headerLines=1)
            np.testing.assert_allclose(values_GENERATED, values_REFERENCE, rtol=max_relative_error, atol=0)
            print("Files {} and {} differ by less than {}%.".format(map2d_file_REFERENCE, map2d_file_GENERATED, max_relative_error * 100))

            # assert 3b - Check that the existing ...E.map2d files are correctly copied
            input_path = os.path.join('model_library', 'magnets', magnet_name, 'input')
            number_input_files = len([entry for entry in os.listdir(input_path) if os.path.isfile(os.path.join(input_path, entry))])

            for file in range(number_input_files + 1):
                path_map2d_E = os.path.join(input_path, magnet_name + '_E{}'.format(file) + '.map2d')
                if os.path.isfile(path_map2d_E):
                    if magnet_name in ['MED_C_COMB']:
                        suffix = '_E{}'.format(file) + '_WithIron_NoSelfField'
                    else:
                        suffix = '_E{}'.format(file) + '_WithIron_WithSelfField'

                    if magnet_type == 'solenoid':
                        suffix = '_E{}'.format(file) + 'NoIron_NoSelfField'

                    map2d_E_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, magnet_name + suffix + "_REFERENCE.map2d")
                    map2d_E_file_GENERATED = os.path.join('model_library', 'magnets', magnet_name, 'output', magnet_name + suffix + ".map2d")
                    values_REFERENCE_E = parseRoxieMap2d(map2d_E_file_REFERENCE, headerLines=1)
                    values_GENERATED_E = parseRoxieMap2d(map2d_E_file_GENERATED, headerLines=1)
                    np.testing.assert_allclose(values_GENERATED_E, values_REFERENCE_E, rtol=max_relative_error, atol=0)
                    print("Files {} and {} differ by less than {}%.".format(map2d_E_file_REFERENCE, map2d_E_file_GENERATED, max_relative_error * 100))

    def _compare_to_reference_ProteCCT(self, magnet_name, verbose=False):
        """
            Helper method called by other methods
            Check that BuilderModel object can be initialized, read a model input yaml file, and generate a ProteCCT model
            This test checks:
             - the content of the generated Excel file against a reference ProteCCT Excel file

            magnet_name: can be any magnet name in the library
        """

        # arrange
        max_relative_error = 1e-6  # Maximum accepted relative error for excel, csv and map2d file comparison
        tool_name = 'ProteCCT'
        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', f'modelData_{magnet_name}.yaml')
        output_path = os.path.join('model_library', 'magnets', magnet_name, 'output')
        input_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, f'{magnet_name}_{tool_name}_REFERENCE.xlsx')
        input_file_GENERATED = os.path.join('model_library', 'magnets', magnet_name, 'output', f'{magnet_name}_{tool_name}.xlsx')

        # act
        BM = BuilderModel(file_model_data=file_model_data, software=['ProteCCT'], flag_build=True, flag_dump_all=False,
                          output_path=output_path, verbose=verbose)

        # assert 1 - Check that the generated ProteCCT file has the same input as the reference
        self.assertTrue(CompareProteCCTParameters(input_file_GENERATED,
                                                   input_file_REFERENCE,
                                                   max_relative_error=max_relative_error, verbose=verbose))
        # # TODO: Write BuilderProteCCT.CompareProteCCTParameters

    def _compare_two_csv_files(self, magnet_name, path_generated=None, path_reference=None,
                               max_relative_error: float = 0):
        """
            Helper method called by other methods to compare csv files
            max_relative_error: Maximum accepted relative error [-]
        """

        # arrange
        if not path_generated:
            path_generated = os.path.join('output', magnet_name, magnet_name + "_selfMutualInductanceMatrix.csv")
        if not path_reference:
            path_reference = os.path.join('references', 'magnets', magnet_name, magnet_name + "_selfMutualInductanceMatrix_REFERENCE.csv")

        data_generated = np.genfromtxt(path_generated, dtype=float, delimiter=',', skip_header=1)
        data_reference = np.genfromtxt(path_reference, dtype=float, delimiter=',', skip_header=1)

        # Check that the number of elements in the generated matrix is the same as in the reference file
        if data_generated.size != data_reference.size:
            raise Exception('Generated csv file does not have the correct size.')

        relative_differences = np.abs(
            data_generated - data_reference) / data_reference  # Matrix with absolute values of relative differences between the two matrices
        max_relative_difference = np.max(np.max(relative_differences))  # Maximum relative difference in the matrix
        self.assertAlmostEqual(0, max_relative_difference,
                               delta=max_relative_error)  # Check that the maximum relative difference is below
        print("Files {} and {} differ by less than {}%.".format(path_generated, path_reference,
                                                                max_relative_difference * 100))

        # Compare the values inside the matrix and check they do not differ from the reference values by more than MAX_RELATIVE_ERROR, element by element [THIS IS REDUNDANT]
        # for row in range(len(data_generated)):
        #     for col in range(len(data_generated[row])):
        #         self.assertAlmostEqual(data_reference[row][col], data_generated[row][col], delta=max_relative_error*np.abs(data_reference[row][col]))

    # The following two tests represent a template for testing the correct writing of a LEDET Excel file and self-mutual inductance csv file
    # def test_BuilderModel_LEDET_MQXF_V2(self, magnet_name='MQXF_V2'):
    #     self.compare_to_reference_LEDET(magnet_name, verbose=False)

    # def test_BuilderModel_SIGMA(self, verbose=False):
    #     """
    #         Check that BuilderModel object can be initialized, read a real model input yaml file, and generate a yaml
    #         file with all model data
    #     """
    #     # arrange
    #     magnet_name = ('MQY_2in1', 'MQXF_V2')
    #     for name in magnet_name:
    #         split_java = 0
    #         file_model_data = os.path.join('input', name, 'modelData_' + name + '.yaml')
    #         for file in os.listdir(os.path.join('references', 'magnets', name)):
    #             if file.endswith(".java"):
    #                 split_java += 1
    #
    #         # act
    #         BuilderModel(file_model_data=file_model_data, software=['SIGMA'], flag_build=True, flag_dump_all=False,
    #                      output_path=os.path.join('output', name), verbose=verbose)
    #         for i in range(split_java):
    #             with open(os.path.join('references', 'magnets', name, name + f'_Model_{i}_REFERENCE.java'), "r") as stream:
    #                 data_references = stream.readlines()
    #             with open(os.path.join('output', name, name + f'_Model_{i}.java'), "r") as stream:
    #                 data_generated = stream.readlines()
    #
    #             # assert - Check that generated SIGMA file has the same input as the reference
    #             self.assertEqual(data_generated, data_references)
