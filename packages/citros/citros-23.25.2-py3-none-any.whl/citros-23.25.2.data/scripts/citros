#!python
import time
from citros import Citros, __version__ as citros_version
import argparse
from getpass import getpass
import os
import sys        
import traceback
from decouple import config

from InquirerPy import prompt
from prompt_toolkit.validation import Validator, ValidationError

from citros.launches import generate_launch_description  


DEFAULT_SIMULATION_TIMEOUT = 10*60  # in seconds


class NumberValidator(Validator):
    """
    small helper class for validating user input during an interactive session.
    """
    def validate(self, document):
        try:
            int(document.text)
        except ValueError:
            raise ValidationError(message="Please enter a number",
                                  cursor_position=len(document.text))



def print_citros():
    print (f"""
==============================================
 ██████╗██╗████████╗██████╗  ██████╗ ███████╗
██╔════╝██║╚══██╔══╝██╔══██╗██╔═══██╗██╔════╝
██║     ██║   ██║   ██████╔╝██║   ██║███████╗
██║     ██║   ██║   ██╔══██╗██║   ██║╚════██║
╚██████╗██║   ██║   ██║  ██║╚██████╔╝███████║
 ╚═════╝╚═╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚══════╝
==============================================
CITROS CLI tool for interaction with the CITROS system. V[{citros_version}]
    """)


def generate_question(type, name, message, choices=None, validator=None, filter=None):
    if type not in ["list", "raw_list", "expand", "confirm",
                    "check_box", "input", "password", "editor"]:
        print("question type not supported.")
        return {}

    if type == "list":
        if not choices:
            print("Nothing to choose from.")
            return {}
        return {
            "type": type,
            "name": name,
            "message": message,
            "choices": choices
        }
    elif type == "input":
        return {
            f"type":type,
            f"name":name,
            f"message": message,
            f"validate": validator,
            f"filter": filter
        }
    else:
        raise NotImplementedError()


def login(args, argv): 
    with Citros() as citros:       
        username, password, key = args.username, args.password, args.key

        if key:
            success = citros.authenticate_with_key(key)
            if success:
                pass
                #print("User authenticated.")
            return

        if not citros.isAuthenticated() and (args.username is None or args.password is None):        
            username = input("email: ")        
            password = getpass()            
        resp = citros.login(username, password) 
        if resp:
            print("User logged in.")
        else:
            print("Failed to log in. Please try again.")

    
def logout(args, argv):
    with Citros() as citros: 
        citros.logout() 
        print("User logged out.")


def sync_project(args, argv):             
    with Citros() as citros:  
        if not citros.isAuthenticated():
            print("sync_project: please log in first!")
            return
        
        project_data = citros.parser_ros2.parse(args.dir, args.name, args.ws)
        citros.integration.sync_project(project_data)


def list_project(args, argv):
    with Citros() as citros:  
        if not citros.isAuthenticated():
            print("list_project: please log in first!")
            return
        
        if args.names:
            i = 1
            for proj in citros.query_projects():
                print(f"{i}. {proj['user']['username']}/{proj['name']}")
                i = i + 1
        else:
            simulations = citros.query_simulations(args.project)
            for s in simulations:
                print(f"{s['id']}\t{s['name']}")


def run(args, argv):
    """
    :param args.simulation_id:
    :param args.batch_id:
    :param args.run_id:
    :param args.remote:
    :param args.timeout:
    :param args.key:
    :param args.completions:
    """
    print_citros()       

    sim_id, batch_id, run_id = args.simulation_id, args.batch_id, args.run_id
    remote, timeout, key, completions = args.remote, args.timeout, args.key, args.completions
    
    global DEBUG
    DEBUG = args.debug

    with Citros() as citros:
        if key:
            loggedin = citros.authenticate_with_key(key)
            if not loggedin:
                sys.exit("run.authenticate_with_key: please log in first!") 
        
        if not citros.isAuthenticated():
            sys.exit("run: please log in first!")

        if batch_id:
            run_simulation_by_batch(citros, batch_id, run_id, timeout)
        elif sim_id:
            run_simulation(citros, sim_id, completions, timeout, remote)
        else:
            proj_name = os.path.abspath(".").split("/")[-1]
            run_simulation_interactively(citros, proj_name, completions, timeout, remote)

        # sys.exit(0)
            

def run_simulation_interactively(citros : Citros, proj_name, completions, timeout, remote):
    proj_names = citros.query_projects()
    proj_names = [n["name"] for n in proj_names]
    if proj_name in proj_names:
        simulations = citros.query_simulations(proj_name)
        
        if not simulations:
            print(f"There are currently no simulations associated with project {proj_name}. \
                    Please login to citros.io and create at least one simulation for your project.")
            return
        
        names_and_ids = [f"{s['name']}  {s['id']}" for s in simulations]
        sim_name_and_id_q = generate_question("list", "sim_name_and_id", 
                                              "Please choose the simulation you wish to run", names_and_ids )
        #completions_q = generate_question("input", "completions", "Please enter number of completions:",
        #                                  NumberValidator, lambda val: int(val))
        answers = prompt([sim_name_and_id_q])  # use default style
        sim_name_and_id = answers.get("sim_name_and_id")
        idx = names_and_ids.index(sim_name_and_id)

        run_simulation(citros, simulations[idx]["id"], completions, timeout, remote)

    else:
        print(f"Your project `{proj_name}` is not known to citros. Please run `citros sync` first.")


def run_simulation(citros : Citros, sim_id, completions, timeout, remote):      
    # create a new batch for this simulation
    isManual = not remote
    where = "locally" if isManual else "on Citros cluster"
    batch_id = citros.batch.create_manual_batch(sim_id, completions, isManual)
    citros.log.info(f"created new batch_run_id: {batch_id}. Running {where}.")
    if isManual:
        batch = citros.batch.get_batch(batch_id)
        run_batch(batch, batch_id, timeout)
    
    
def run_batch(batch, batch_run_id, timeout):
    completions = 0
    try:
        completions = int(batch["batchRun"]["completions"])
    except Exception as e:
        print(e)
    print(f" + running batch [{batch_run_id}], repeating simulations: [{completions}]")
    for sid in range(0, completions):
        try:
            single_simulation_run(batch_run_id, sid, timeout)                        
            time.sleep(1)
        except Exception as e:
            print("------------------------")   
            print (e)
            traceback.print_exc()
            print("------------------------")
            continue
    print(f" - Finished [{batch_run_id}] batch.")    


def single_simulation_run(batch_id, run_id, timeout):   
    # running inside ROS workspace context.  
    from launch import LaunchService 

    print(f" + + running simulation [{run_id}]")  
    
    # create a new instance of citros so that a new logger will be created 
    # and mapped according to batch_id and run_id. Very inelegant.
    # TODO: find a simple way to map the loggers without instantiating Citros. 
    with Citros(batch_id, run_id) as citros:
        launch_description = generate_launch_description(citros, str(timeout))

        if launch_description is None:
            sys.exit(f'Couldn\'t run run_id:[{run_id}]. Something went wrong,\
                      probably with connection to CITROS. ')

        launch_service = LaunchService(debug=DEBUG)
        launch_service.include_launch_description(launch_description)
        ret = launch_service.run()    
        print(f" - - Finished simulation run_id = [{run_id}] with return code [{ret}].")    
    

def run_simulation_by_batch(citros : Citros, batch_id, run_id, timeout):
    # k8s indexed batch job is passing the index with JOB_COMPLETION_INDEX env variable.
    if run_id == "JOB_COMPLETION_INDEX":
        run_id = config("JOB_COMPLETION_INDEX", "bad-value-from-k8s")
        print(f"got JOB_COMPLETION_INDEX={run_id} from k8s.")
    
    if (run_id == ''):
        print(f"running batch [{batch_id}]")
        batch = citros.batch.get_batch(batch_id)
        run_batch(batch, batch_id, str(timeout))
        return       
    else:    
        print(f"running a single simulation run from batch [{batch_id}]")
        single_simulation_run(batch_id, run_id, str(timeout))


# experimental:
def load_params(args, argv):
    with Citros() as citros: 
        if not citros.isAuthenticated():
            print("load_params: please log in first!")
            return
        # TODO: source the ros project to env terminal
        citros.params.init_params(args.batch_run_id, args.sid)


# experimental:
def upload_bag(args, argv): 
    # print("upload_bag")
    with Citros() as citros: 
        if not citros.isAuthenticated():
            print("upload_bag: please log in first!")
            return
        bag_resp, batch_text, resp_json = citros.bag.emit(args.bag, args.batch_run_id, args.sid)        
        print("bag_resp, ", bag_resp)
        print("batch_text", batch_text)
        print("resp_json", resp_json)


def docker_login(argx, argv):
    with Citros() as citros: 
        google_access_token = citros.get_access_token()
        if google_access_token is None:
            print("failed to authenticate to SA.")
            return 
        
        # print( 'echo ' + google_access_token + ' | docker login -u oauth2accesstoken --password-stdin https://europe-west2-docker.pkg.dev')
        os.system('echo ' + google_access_token + ' | docker login -u oauth2accesstoken --password-stdin https://us-central1-docker.pkg.dev')                        


def docker(args, argv):
    # TODO: login to docker first
    os.system('docker ' + ' '.join(argv))


def stress_user_db(args, argv):
    """
    args.runs - how many query's to send,
    args.sleep - how much sleep between sends. 
    """      
    print("Starting stress test for citros.")
    with Citros(batch_run_id=args.batch_run_id, simulation_run_id=args.sid) as citros: 
        if not citros.isAuthenticated():
            print("stress_user_db: please log in first!")
            return
        
        print(f"sending {args.runs} log messages.")
        for i in range(1, int(args.runs) + 1):
            # print(f"sending {i} message.")
            citros.events.creating("72311c81-5992-431a-9373-81aa2bdb3fe1", "2", "vova", "stress test", "")
            # citros.log.debug(f"{i} - sending message.")
            if float(args.sleep) > 0:
                time.sleep(float(args.sleep))    
    print("Done.")    



def main():    
    parser = argparse.ArgumentParser(
        prog='CITROS ROS parser',
        description=f'''
==============================================
 ██████╗██╗████████╗██████╗  ██████╗ ███████╗
██╔════╝██║╚══██╔══╝██╔══██╗██╔═══██╗██╔════╝
██║     ██║   ██║   ██████╔╝██║   ██║███████╗
██║     ██║   ██║   ██╔══██╗██║   ██║╚════██║
╚██████╗██║   ██║   ██║  ██║╚██████╔╝███████║
 ╚═════╝╚═╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚══════╝
==============================================
CITROS CLI tool for interaction with the CITROS system. V[{citros_version}]
        ''',
        epilog='''
-----------------------------------------  
\t Powered by Lulav Space

        ''',
        formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-V', "--version",
                        action="version",
                        version="CITROS " + citros_version)
    
    subparsers = parser.add_subparsers(title="commands", help="citros commands", dest='command', required=True)

    # -----------------------------------------
    build_parser = subparsers.add_parser("login", help="log in to citros")
    build_parser.add_argument("-username", default=None, help="username")
    build_parser.add_argument("-password", default=None, help="password")
    build_parser.add_argument("-k", "--key", default=None, help="authentication key")
    build_parser.set_defaults(func=login)
    
    # -----------------------------------------
    build_parser = subparsers.add_parser("logout", help="log out of the system")
    build_parser.set_defaults(func=logout)
    
    # -----------------------------------------
    current_folder_name = os.path.abspath(".").split("/")[-1]
    
    build_parser = subparsers.add_parser("sync", help="sync the ros project to citros")
    build_parser.add_argument("-dir", default=".", help="The working dir of the project")
    build_parser.add_argument("-name", default=current_folder_name, help="The project name of the project")
    build_parser.add_argument('-w','--ws', action='append', default=[""], help='workspaces list')
    build_parser.set_defaults(func=sync_project)

    # -----------------------------------------
    build_parser = subparsers.add_parser("list", help="lists project names, simulation IDs or batch IDs.")
    build_parser.add_argument("-p", "--project", default=current_folder_name, help="The project name whose simulations ids will be printed.")
    build_parser.add_argument("-n", "--names", action="store_true", help="if used, list all available project names.")
    build_parser.set_defaults(func=list_project)

    # experimental
    # -----------------------------------------
    build_parser = subparsers.add_parser("params", help="generating parameters to the project")
    build_parser.add_argument("batch_run_id", help="Batch run id")
    build_parser.add_argument("sid", help="simulation run id")
    build_parser.set_defaults(func=load_params)
        
    # -----------------------------------------
    build_parser = subparsers.add_parser("run", help="run a simulation")
    #build_parser.add_argument("-n", "--name", default=current_folder_name, help="The project name of the project")
    build_parser.add_argument("-s", "--simulation_id", nargs='?', default=None, help="Simulation id")
    build_parser.add_argument("-b", "--batch_id", nargs='?', default=None, help="Batch id")
    build_parser.add_argument("-i", "--run_id", nargs='?', default='', help="run id")
    build_parser.add_argument("-c", "--completions", nargs='?', default=1, help="number of times to run the simulation")
    build_parser.add_argument("-t", "--timeout", nargs='?', default=DEFAULT_SIMULATION_TIMEOUT, help="simulation timeout")
    build_parser.add_argument("-k", "--key", nargs='?', default=None, help="jwt key of the user")
    build_parser.add_argument("-r", "--remote", action='store_true', help="simulation timeout")
    build_parser.add_argument("-d", "--debug", action='store_true', help="simulation timeout")
    build_parser.set_defaults(func=run)
     
    # experimental
    # -----------------------------------------
    build_parser = subparsers.add_parser("upload_bag", help="upload bag to citros")
    build_parser.add_argument("bag", help="bag file")
    build_parser.add_argument("batch_run_id", help="Batch run id")
    build_parser.add_argument("sid", help="simulation run id")  
    build_parser.set_defaults(func=upload_bag)
    
    # experimental
    # -----------------------------------------
    build_parser = subparsers.add_parser("stress", help="stress test the system")
    build_parser.add_argument("--batch_run_id", help="Batch run id")
    build_parser.add_argument("--sid", help="simulation run id")
    build_parser.add_argument("--runs", default=100,help="how many runs to perform")
    build_parser.add_argument("--sleep", default=0.0, help="how much sleep between runs")      
    build_parser.set_defaults(func=stress_user_db)
    
    # -----------------------------------------
    build_parser = subparsers.add_parser("docker-login", help="Builds the project")
    build_parser.set_defaults(func=docker_login)
    
    build_parser = subparsers.add_parser("docker", help="Builds the project")
    build_parser.add_argument("-d", default="Dockerfile", help="The docker to build")
    build_parser.set_defaults(func=docker)

    args, argv = parser.parse_known_args()
    
    args.func(args, argv)     


if __name__ == "__main__":
    main()