Metadata-Version: 2.1
Name: ipsocgen
Version: 0.1.39
Summary: Generic SoC builder in HDL
Home-page: https://github.com/aignacio/ipsocgen
Author: aignacio (Anderson Ignacio)
Author-email: <anderson@aignacio.com>
Keywords: soc,mpsoc,hdl,verilog,systemverilog,builder
Classifier: Development Status :: 1 - Planning
Classifier: Intended Audience :: Developers
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: Unix
Classifier: Operating System :: MacOS :: MacOS X
Classifier: Operating System :: Microsoft :: Windows
Description-Content-Type: text/markdown
License-File: LICENSE


# IP SoC Generator

**IP SoC gen** is a framework to generate MP/SoCs with different configurations through a set of masters/slaves for fast
digital design development. To install through pip: 
```bash
pip install --upgrade ipsocgen
```

## Template projects 
In order to get started generating your own designs, check the [template
repository](https://github.com/aignacio/ipsocgen_template) which contains an example of SoC and MPSoC using
[NoX](https://github.com/aignacio/nox)
processor as the main CPU. The configuration files that were used for the **ipsocgen_template** are available in [`ipsocgen/examples/template_soc.yaml`](ipsocgen/examples/template_soc.yaml) and [`ipsocgen/examples/template_mpsoc.yaml`](ipsocgen/examples/template_mpsoc.yaml).

## To contribute/develop/extend the work
Please follow the steps below to build the virtual environment and install the dependencies.
```bash
python3 -m venv venv
source venv/bin/activate 
python3 setup.py install
```
## Configuration file reference

Here is a list of all inputs that can be listed for the IPSoCGen configuration file in yaml format.
```yaml
proj_name:                #Project Name
desc: 	                  #Short description
type:                     #System type (soc or mpsoc)

#####################
# If type == soc
#####################

soc_desc:
  bus_name:		            #Name for the bus Interconnect
  bus_type:	  	          #Type of the bus
  addr_width: 	          #Bus adress width			
  data_width:	  	        #Bus data width
  txn_id_width:  	        #Bus transaction ID width
  num_masters:	          #Number of master in the bus (min == 1)
  num_slaves:    	        #Number of slave in the bus (min == 1)
  proc_required:	        #Set if a processor is required (y or n)
  mmap_type:     	        #Memory map type (manual or auto)
  clk:
    name: 		            #Clock name
    clk_int: 		          #Internal signal name for the clock
    io_in_clk: 		        #Wrapper input pin for the clock
    type:  		            #Type of clock (pll or direct)
    pll:  		            #Only applicable if type == pll
      divclk_divide:      #PLL parameters
      clkfbout_mult:	    #PLL parameters
      clkout_divide:	    #PLL parameters
      io_rst_pin:         #Wrapper input pin for the PLL reset
      rst_in_type:        #Type of reset for the PLL (act_l or act_h)
      clkin_period:       #PLL parameters
  rst: 
    name:   		          #Reset name
    rst_int:  		        #Internal signal name for the reset
    io_in_rst: 		        #Wrapper input pin for the reset
    rst_in_type:  	      #Type of reset for the PLL (act_l or act_h)
    type:         		    #Type of reset (acc_rst or direct)
  proc:		
    name: 		            #Name of the main CPU that will be used
    type:		              #Type of processor (nox, vex…)
    clk: 		              #Describe the clock of the processor
    rst: 		              #Describe the reset of the processor
    boot:		              #Describe the boot for this processor
      type:   	 	        #Type of boot (slave, value or signal)
      signal:  	 	        #Only applicable if type == signal
      slave: 		          #Only applicable if type == slave
      value:        	    #Only applicable if type == value
    irq_mapping:
      timer:    		      #Internal signal name for RV timer interrupts
      software: 		      #Internal signal name for RV software interrupts
      external: 		      #Internal signal name for RV external interrupts
  masters:		            #Describe all masters within the system
    x:		                #Master ID, start always from 0
      name: 		          #Unique name for the instance
      desc: 		          #Brief description of the master I/F
      type: 	      	    #Master type
      if:   		          #Interface name (must be a valid one supported)
    ...
  slaves:
    x:		                #Slave ID, start always from 0
      name: 		          #Unique name for the instance
      desc: 		          #Brief description of the slave
      type:		            #Slave type
      base_addr:	        #Base address if mmap_type == manual
      addr_width:	        #Base address if mmap_type == manual
      mem_size_kib:	      #Slave kib size, only applicable if type == ram_mem/rom_mem/acc_custom_slave
      irq_timer:		      #Timer internal signal name, only applicable if type == acc_timer
      rst_def_addr:	      #Reset default address, only applicable if type == acc_rst
      rst_addr_out:	      #Reset address signal name [usually for CPUs], only applicable if type == acc_rst
      rst_pulse_width: 	  #Reset address signal name [usually for CPUs], only applicable if type == acc_rst
      io_bootloader:	    #Wrapper input pin for the bootloader, only applicable if type == acc_rst
      bootloader_type:    #Bootloader type (act_l or act_h), only applicable if type == acc_rst
      irq_dma_done:	      #Internal signal name for the DMA done IRQ, only applicable if type == acc_dma
      irq_dma_error:  	  #Internal signal name for the DMA error IRQ, only applicable if type == acc_dma
      io_tx:		          #Wrapper output pin for the UART TX, only applicable if type == acc_uart
      io_rx:		          #Wrapper input pin for the UART TX, only applicable if type == acc_uart
      irq_uart_rx:	      #Internal signal name for the UART IRQ, only applicable if type == acc_uart
      irq_type:		        #IRQ type (0-level, 1-edge) for all incomming IRQs, only applicable if type == acc_irq
      irq_summary:	      #Internal signal name for the IRQ summary, only applicable if type == acc_irq
      vec_mapping:	      #List of all internal signal names for the IRQ vector, only applicable if type == acc_irq
         - highest_prior_irq_1
         - …
         - lowest_prior_irq_n
      irq_noc:	      	  #Internal signal name for the NoC IRQ, only applicable if type == acc_noc
      pkt_recv_irq:	      #Internal signal name for the Received Packet IRQ, only applicable if type == acc_eth
      pkt_sent_irq:	      #Internal signal name for the Packet sent IRQ, only applicable if type == acc_eth
      pkt_recv_full_irq:	#Internal signal name for the Full FIFO Recv. Packet IRQ, only applicable if type == acc_eth
      eth_type:		        #Ethernet slave type (csr, infifo or outfifo), only applicable if type == acc_eth
    ...

#####################
# If type == mpsoc
#####################
mpsoc_desc:
  clk:
    name: 		            #Clock name
    clk_int: 		          #Internal signal name for the clock
    io_in_clk: 		        #Wrapper input pin for the clock
    type:  		            #Type of clock (pll or direct)
    pll:  		            #Only applicable if type == pll
      divclk_divide:      #PLL parameters
      clkfbout_mult:	    #PLL parameters
      clkout_divide:	    #PLL parameters
      io_rst_pin:         #Wrapper input pin for the PLL reset
      rst_in_type:        #Type of reset for the PLL (act_l or act_h)
      clkin_period:       #PLL parameters
  rst: 
    name:   		          #Reset name
    rst_int:  		        #Internal signal name for the reset
    io_in_rst: 		        #Wrapper input pin for the reset
    rst_in_type:  	      #Type of reset for the PLL (act_l or act_h)
    type:         		    #Type of reset (acc_rst or direct)
  noc:
    type:                 #Type of the noc (currently only ravenoc is available)
    name:                 #Unique name for the NoC instance
    size_x:               #Num. of rows
    size_y:               #Num. of collumns
    flit_data_width:      #Data width of the flit
    flit_buff:            #Num. of flit buffers
    h_priority:           #Priority of the virtual channels (ZeroHighPrior or ZeroLowPrior)
    n_virt_chn:           #Num. of virtual channels
    routing_alg:          #Routing algorithm (XYAlg or YXAlg)
    max_sz_pkt:           #Max. size of packet in flits (usually 256)
    base_addr:            #NoC common base address across all Tiles
  tiles:
    x:                    #Tile ID, always start from zero
      ....                #Same description pattern as soc_desc
```

